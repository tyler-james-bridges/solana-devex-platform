<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LiteSVM Protocol Testing Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: between;
            align-items: center;
        }
        
        .header h1 {
            font-size: 1.8rem;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.connected {
            background: #27ae60;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }
        
        .protocol-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .protocol-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.7);
            transition: all 0.3s ease;
        }
        
        .protocol-checkbox:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
        }
        
        .protocol-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }
        
        .start-test-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .start-test-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .start-test-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }
        
        .card h3 {
            margin-bottom: 1rem;
            color: #2c3e50;
            font-size: 1.2rem;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .metric {
            text-align: center;
            padding: 1rem;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }
        
        .metric-label {
            font-size: 0.8rem;
            color: #666;
            margin-top: 0.25rem;
        }
        
        .test-item {
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.7);
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }
        
        .test-item:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateX(5px);
        }
        
        .test-item.running {
            border-left-color: #f39c12;
            animation: pulse 2s infinite;
        }
        
        .test-item.completed {
            border-left-color: #27ae60;
        }
        
        .test-item.failed {
            border-left-color: #e74c3c;
        }
        
        .test-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .test-id {
            font-family: monospace;
            font-size: 0.9rem;
            color: #666;
        }
        
        .test-status {
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .test-status.running {
            background: #f39c12;
            color: white;
        }
        
        .test-status.completed {
            background: #27ae60;
            color: white;
        }
        
        .test-status.failed {
            background: #e74c3c;
            color: white;
        }
        
        .test-protocols {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
        }
        
        .protocol-tag {
            background: #667eea;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
        }
        
        .test-results {
            font-size: 0.9rem;
            color: #666;
        }
        
        .log-container {
            background: #1e1e1e;
            color: #00ff00;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 1rem;
        }
        
        .log-entry {
            margin-bottom: 0.25rem;
            padding: 0.25rem;
            border-radius: 3px;
        }
        
        .log-entry.error {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }
        
        .log-entry.success {
            background: rgba(39, 174, 96, 0.2);
            color: #27ae60;
        }
        
        .log-entry.info {
            color: #3498db;
        }
        
        .floating-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 1.5rem;
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            border-left: 4px solid #667eea;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        
        .floating-notification.show {
            transform: translateX(0);
        }
        
        .btn-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>
            üß™ LiteSVM Protocol Testing Dashboard
            <span class="status-indicator" id="statusIndicator"></span>
        </h1>
        <div>
            <span id="connectionStatus">Disconnected</span>
        </div>
    </header>

    <div class="container">
        <!-- Test Controls -->
        <div class="controls">
            <h3>üöÄ Start New Test</h3>
            <div class="protocol-selector">
                <label class="protocol-checkbox">
                    <input type="checkbox" value="jupiter" checked>
                    <span>ü™ê Jupiter</span>
                </label>
                <label class="protocol-checkbox">
                    <input type="checkbox" value="raydium" checked>
                    <span>üåä Raydium</span>
                </label>
                <label class="protocol-checkbox">
                    <input type="checkbox" value="kamino" checked>
                    <span>üí∞ Kamino</span>
                </label>
                <label class="protocol-checkbox">
                    <input type="checkbox" value="drift" checked>
                    <span>‚ö° Drift</span>
                </label>
                <label class="protocol-checkbox">
                    <input type="checkbox" value="marinade" checked>
                    <span>üåä Marinade</span>
                </label>
            </div>
            <button class="start-test-btn" id="startTestBtn">Start Protocol Tests</button>
        </div>

        <!-- Dashboard Grid -->
        <div class="dashboard-grid">
            <!-- Metrics Card -->
            <div class="card">
                <h3>üìä Test Metrics</h3>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="totalTests">0</div>
                        <div class="metric-label">Total Tests</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="activeTests">0</div>
                        <div class="metric-label">Active</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="passRate">0%</div>
                        <div class="metric-label">Pass Rate</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="avgDuration">0ms</div>
                        <div class="metric-label">Avg Duration</div>
                    </div>
                </div>
            </div>

            <!-- System Status Card -->
            <div class="card">
                <h3>‚ö° System Status</h3>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="systemStatus">Healthy</div>
                        <div class="metric-label">Status</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="memoryUsage">0MB</div>
                        <div class="metric-label">Memory</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="uptime">0s</div>
                        <div class="metric-label">Uptime</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="connectedClients">0</div>
                        <div class="metric-label">Clients</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Active Tests -->
        <div class="card">
            <h3>üî¨ Active & Recent Tests</h3>
            <div id="testsList">
                <p style="text-align: center; color: #666; padding: 2rem;">
                    No tests running. Start a test to see results here.
                </p>
            </div>
        </div>

        <!-- Live Logs -->
        <div class="card">
            <h3>üìù Live Logs</h3>
            <div class="log-container" id="logContainer">
                <div class="log-entry info">[INFO] Dashboard connected to Testing API</div>
                <div class="log-entry info">[INFO] Waiting for test execution...</div>
            </div>
        </div>
    </div>

    <!-- Floating Notification -->
    <div class="floating-notification" id="notification">
        <div id="notificationText"></div>
    </div>

    <script>
        class TestingDashboard {
            constructor() {
                this.ws = null;
                this.tests = new Map();
                this.metrics = {
                    totalTests: 0,
                    activeTests: 0,
                    passRate: 0,
                    avgDuration: 0
                };
                
                this.init();
            }

            init() {
                this.connectWebSocket();
                this.setupEventListeners();
                this.loadTestHistory();
                this.updateMetrics();
                
                // Update status every 30 seconds
                setInterval(() => this.updateSystemStatus(), 30000);
            }

            connectWebSocket() {
                const wsUrl = `ws://${window.location.host}/ws`;
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        this.updateConnectionStatus(true);
                        this.addLog('Connected to Testing API', 'success');
                    };
                    
                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleWebSocketMessage(data);
                    };
                    
                    this.ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.updateConnectionStatus(false);
                        this.addLog('Disconnected from Testing API', 'error');
                        
                        // Reconnect after 5 seconds
                        setTimeout(() => this.connectWebSocket(), 5000);
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.addLog('WebSocket connection error', 'error');
                    };
                    
                } catch (error) {
                    console.error('Failed to connect WebSocket:', error);
                    this.updateConnectionStatus(false);
                }
            }

            updateConnectionStatus(connected) {
                const indicator = document.getElementById('statusIndicator');
                const status = document.getElementById('connectionStatus');
                
                if (connected) {
                    indicator.classList.add('connected');
                    status.textContent = 'Connected';
                } else {
                    indicator.classList.remove('connected');
                    status.textContent = 'Disconnected';
                }
            }

            handleWebSocketMessage(data) {
                console.log('WebSocket message:', data);
                
                switch (data.type) {
                    case 'test_started':
                        this.handleTestStarted(data);
                        break;
                    case 'test_completed':
                        this.handleTestCompleted(data);
                        break;
                    case 'test_failed':
                        this.handleTestFailed(data);
                        break;
                    case 'connection':
                        this.addLog(data.message, 'info');
                        break;
                }
            }

            handleTestStarted(data) {
                this.addLog(`Test ${data.testId} started: ${data.protocols.join(', ')}`, 'info');
                this.showNotification(`Test started: ${data.protocols.join(', ')}`);
                this.addTestToList(data.testId, data.protocols, 'running');
                this.updateMetrics();
            }

            handleTestCompleted(data) {
                this.addLog(`Test ${data.testId} completed successfully`, 'success');
                this.showNotification(`Test completed: ${data.results.passed}/${data.results.total} passed`);
                this.updateTestStatus(data.testId, 'completed', data.results);
                this.updateMetrics();
            }

            handleTestFailed(data) {
                this.addLog(`Test ${data.testId} failed: ${data.error}`, 'error');
                this.showNotification(`Test failed: ${data.error}`);
                this.updateTestStatus(data.testId, 'failed', null, data.error);
                this.updateMetrics();
            }

            setupEventListeners() {
                const startBtn = document.getElementById('startTestBtn');
                startBtn.addEventListener('click', () => this.startTest());
            }

            async startTest() {
                const checkboxes = document.querySelectorAll('.protocol-checkbox input:checked');
                const protocols = Array.from(checkboxes).map(cb => cb.value);
                
                if (protocols.length === 0) {
                    this.showNotification('Please select at least one protocol');
                    return;
                }
                
                const startBtn = document.getElementById('startTestBtn');
                startBtn.disabled = true;
                startBtn.textContent = 'Starting Test...';
                
                try {
                    const response = await fetch('/api/test/protocols', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ protocols })
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                        this.addLog(`Started test ${result.testId}`, 'success');
                        this.showNotification('Test started successfully');
                    } else {
                        throw new Error(result.message || 'Failed to start test');
                    }
                    
                } catch (error) {
                    console.error('Failed to start test:', error);
                    this.addLog(`Failed to start test: ${error.message}`, 'error');
                    this.showNotification('Failed to start test');
                } finally {
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Protocol Tests';
                }
            }

            async loadTestHistory() {
                try {
                    const response = await fetch('/api/test/history?limit=10');
                    const data = await response.json();
                    
                    if (data.tests && data.tests.length > 0) {
                        const testsList = document.getElementById('testsList');
                        testsList.innerHTML = '';
                        
                        data.tests.forEach(test => {
                            this.addTestToList(test.id, test.protocols, test.status, test.summary, test.duration);
                        });
                    }
                    
                } catch (error) {
                    console.error('Failed to load test history:', error);
                }
            }

            addTestToList(testId, protocols, status, summary = null, duration = null, error = null) {
                const testsList = document.getElementById('testsList');
                
                // Remove placeholder if exists
                if (testsList.querySelector('p')) {
                    testsList.innerHTML = '';
                }
                
                const testItem = document.createElement('div');
                testItem.className = `test-item ${status}`;
                testItem.id = `test-${testId}`;
                
                const protocolTags = protocols.map(p => 
                    `<span class="protocol-tag">${this.getProtocolIcon(p)} ${p}</span>`
                ).join('');
                
                const resultsHtml = summary ? `
                    <div class="test-results">
                        Results: ${summary.passed}/${summary.total} passed 
                        ${duration ? `(${duration}ms)` : ''}
                    </div>
                ` : error ? `
                    <div class="test-results" style="color: #e74c3c;">
                        Error: ${error}
                    </div>
                ` : '';
                
                testItem.innerHTML = `
                    <div class="test-header">
                        <span class="test-id">${testId}</span>
                        <span class="test-status ${status}">${status}</span>
                    </div>
                    <div class="test-protocols">${protocolTags}</div>
                    ${resultsHtml}
                    <div class="btn-group">
                        ${summary ? `<button class="btn btn-primary" onclick="dashboard.viewResults('${testId}')">View Results</button>` : ''}
                        <button class="btn btn-secondary" onclick="dashboard.exportResults('${testId}')">Export</button>
                        <button class="btn btn-danger" onclick="dashboard.deleteTest('${testId}')">Delete</button>
                    </div>
                `;
                
                testsList.insertBefore(testItem, testsList.firstChild);
            }

            updateTestStatus(testId, status, summary = null, error = null) {
                const testItem = document.getElementById(`test-${testId}`);
                if (testItem) {
                    testItem.className = `test-item ${status}`;
                    
                    const statusSpan = testItem.querySelector('.test-status');
                    statusSpan.className = `test-status ${status}`;
                    statusSpan.textContent = status;
                    
                    if (summary) {
                        const existingResults = testItem.querySelector('.test-results');
                        if (existingResults) {
                            existingResults.innerHTML = `Results: ${summary.passed}/${summary.total} passed (${summary.duration}ms)`;
                        } else {
                            const resultsDiv = document.createElement('div');
                            resultsDiv.className = 'test-results';
                            resultsDiv.innerHTML = `Results: ${summary.passed}/${summary.total} passed (${summary.duration}ms)`;
                            testItem.appendChild(resultsDiv);
                        }
                    }
                    
                    if (error) {
                        const existingResults = testItem.querySelector('.test-results');
                        if (existingResults) {
                            existingResults.innerHTML = `Error: ${error}`;
                            existingResults.style.color = '#e74c3c';
                        }
                    }
                }
            }

            getProtocolIcon(protocol) {
                const icons = {
                    jupiter: 'ü™ê',
                    raydium: 'üåä',
                    kamino: 'üí∞',
                    drift: '‚ö°',
                    marinade: 'üåä'
                };
                return icons[protocol] || 'üî¨';
            }

            async updateMetrics() {
                try {
                    const response = await fetch('/api/metrics');
                    const data = await response.json();
                    
                    document.getElementById('totalTests').textContent = data.totalTests || 0;
                    document.getElementById('activeTests').textContent = data.activeTests || 0;
                    document.getElementById('connectedClients').textContent = data.connectedClients || 0;
                    
                    // Update memory usage
                    const memoryMB = Math.round((data.memory?.heapUsed || 0) / 1024 / 1024);
                    document.getElementById('memoryUsage').textContent = `${memoryMB}MB`;
                    
                    // Update uptime
                    const uptimeDays = Math.floor((data.uptime || 0) / 86400);
                    const uptimeHours = Math.floor(((data.uptime || 0) % 86400) / 3600);
                    const uptimeMinutes = Math.floor(((data.uptime || 0) % 3600) / 60);
                    document.getElementById('uptime').textContent = 
                        uptimeDays > 0 ? `${uptimeDays}d ${uptimeHours}h` : 
                        uptimeHours > 0 ? `${uptimeHours}h ${uptimeMinutes}m` : 
                        `${uptimeMinutes}m`;
                    
                } catch (error) {
                    console.error('Failed to update metrics:', error);
                }
            }

            async updateSystemStatus() {
                try {
                    const response = await fetch('/health');
                    const data = await response.json();
                    
                    document.getElementById('systemStatus').textContent = 
                        data.status === 'healthy' ? 'Healthy' : 'Issues';
                    
                } catch (error) {
                    document.getElementById('systemStatus').textContent = 'Offline';
                }
            }

            addLog(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                
                const timestamp = new Date().toLocaleTimeString();
                const prefix = type === 'error' ? '[ERROR]' : 
                             type === 'success' ? '[SUCCESS]' : '[INFO]';
                
                logEntry.textContent = `${timestamp} ${prefix} ${message}`;
                
                logContainer.insertBefore(logEntry, logContainer.firstChild);
                
                // Keep only last 50 entries
                while (logContainer.children.length > 50) {
                    logContainer.removeChild(logContainer.lastChild);
                }
            }

            showNotification(message) {
                const notification = document.getElementById('notification');
                const text = document.getElementById('notificationText');
                
                text.textContent = message;
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }

            async viewResults(testId) {
                window.open(`/api/test/${testId}/results?format=html`, '_blank');
            }

            async exportResults(testId) {
                window.open(`/api/test/${testId}/results?format=csv`, '_blank');
            }

            async deleteTest(testId) {
                if (!confirm(`Delete test ${testId}? This cannot be undone.`)) {
                    return;
                }
                
                try {
                    const response = await fetch(`/api/test/${testId}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.ok) {
                        const testItem = document.getElementById(`test-${testId}`);
                        if (testItem) {
                            testItem.remove();
                        }
                        this.addLog(`Deleted test ${testId}`, 'success');
                        this.showNotification('Test deleted successfully');
                    } else {
                        throw new Error('Failed to delete test');
                    }
                    
                } catch (error) {
                    this.addLog(`Failed to delete test: ${error.message}`, 'error');
                    this.showNotification('Failed to delete test');
                }
            }
        }

        // Initialize dashboard
        const dashboard = new TestingDashboard();
    </script>
</body>
</html>